# 模块5: 智能生成核心
import json
import time
import random
import re
import copy
import threading
from typing import Dict, List, Any, Optional, Tuple, Callable
from dataclasses import dataclass
from enum import Enum
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
from queue import Queue, PriorityQueue
import hashlib
from 模块2_配置管理 import 获取配置管理器
from 模块4_风格管理 import 获取风格管理系统, 风格参数

class 生成状态(Enum):
    等待中 = "waiting"
    生成中 = "generating"
    完成 = "completed"
    失败 = "failed"
    审核中 = "reviewing"

class 质量等级(Enum):
    优秀 = "excellent"
    良好 = "good"
    一般 = "average"
    较差 = "poor"

@dataclass
class 生成参数:
    """生成参数配置"""
    主题: str
    风格: str
    目标字数: int
    上下文: str = ""
    标签列表: List[str] = None
    冲突优先: List[str] = None
    智能配比: Dict[str, float] = None
    情感基调: str = ""
    节奏控制: str = ""
    特殊要求: List[str] = None
    
    def __post_init__(self):
        if self.标签列表 is None:
            self.标签列表 = []
        if self.冲突优先 is None:
            self.冲突优先 = []
        if self.智能配比 is None:
            self.智能配比 = {}
        if self.特殊要求 is None:
            self.特殊要求 = []

@dataclass
class 生成结果:
    """生成结果数据"""
    状态: 生成状态
    内容: str
    质量评分: float
    质量等级: 质量等级
    实际字数: int
    生成时间: float
    版本号: int
    标签: List[str]
    冲突检测: Dict[str, Any]
    审核结果: Dict[str, Any] = None
    用户反馈: Dict[str, Any] = None

class 上下文管理器:
    """上下文管理器 - 维护生成连贯性"""
    def __init__(self):
        self.配置管理器 = 获取配置管理器()
        self.日志器 = logging.getLogger('上下文管理器')
        self.上下文缓存 = {}
        self.最大缓存大小 = self.配置管理器.获取配置("高级设置.缓存大小_MB", 500) * 1024 * 1024 // 1000  # 估算条目数
        self.当前缓存大小 = 0
        
    def 获取上下文(self, 会话ID: str, 最大长度: int = 2000) -> str:
        """获取指定会话的上下文"""
        if 会话ID not in self.上下文缓存:
            return ""
        
        上下文记录 = self.上下文缓存[会话ID]
        # 合并最近的上下文
        合并上下文 = "\n".join([记录["内容"] for 记录 in 上下文记录[-5:]])  # 最近5条
        return 合并上下文[-最大长度:]  # 限制长度
    
    def 添加上下文(self, 会话ID: str, 内容: str, 元数据: Dict[str, Any] = None):
        """添加新的上下文记录"""
        if 会话ID not in self.上下文缓存:
            self.上下文缓存[会话ID] = []
        
        记录 = {
            "内容": 内容,
            "时间戳": time.time(),
            "元数据": 元数据 or {}
        }
        
        self.上下文缓存[会话ID].append(记录)
        
        # 限制上下文长度
        if len(self.上下文缓存[会话ID]) > 20:  # 最多保存20条记录
            self.上下文缓存[会话ID] = self.上下文缓存[会话ID][-20:]
        
        # 更新缓存大小
        self.当前缓存大小 += len(内容)
        
        # 如果缓存过大，清理最旧的记录
        self.清理缓存()
    
    def 清理缓存(self):
        """清理过期的缓存"""
        if self.当前缓存_size <= self.最大缓存大小:
            return
        
        # 按时间排序，删除最旧的
        所有记录 = []
        for 会话ID, 记录列表 in self.上下文缓存.items():
            for 记录 in 记录列表:
                所有记录.append((记录["时间戳"], 会话ID, 记录))
        
        所有记录.sort(key=lambda x: x[0])  # 按时间戳排序
        
        # 删除最旧的50%
        删除数量 = len(所有记录) // 2
        for 时间戳, 会话ID, 记录 in 所有记录[:删除数量]:
            self.上下文缓存[会话ID] = [r for r in self.上下文缓存[会话ID] if r["时间戳"] != 时间戳]
            self.当前缓存大小 -= len(记录["内容"])
            
            # 如果会话为空，删除整个会话
            if not self.上下文缓存[会话ID]:
                del self.上下文缓存[会话ID]
    
    def 分析上下文连贯性(self, 会话ID: str, 新内容: str) -> Dict[str, Any]:
        """分析新内容与上下文的连贯性"""
        上下文 = self.获取上下文(会话ID)
        if not 上下文:
            return {"连贯性评分": 1.0, "问题": [], "建议": []}
        
        问题列表 = []
        建议列表 = []
        
        # 检查人物一致性
        人物连贯性 = self.检查人物连贯性(上下文, 新内容)
        if 人物连贯性["评分"] < 0.7:
            问题列表.append(f"人物设定不一致: {人物连贯性['问题']}")
            建议列表.append("请检查人物名称和特征是否一致")
        
        # 检查情节连贯性
        情节连贯性 = self.检查情节连贯性(上下文, 新内容)
        if 情节连贯性["评分"] < 0.8:
            问题列表.append("情节发展不连贯")
            建议列表.append("请确保情节发展符合逻辑顺序")
        
        # 检查时间连贯性
        时间连贯性 = self.检查时间连贯性(上下文, 新内容)
        if 时间连贯性["评分"] < 0.9:
            问题列表.append("时间线不一致")
            建议列表.append("请检查事件发生的时间顺序")
        
        连贯性评分 = min(人物连贯性["评分"], 情节连贯性["评分"], 时间连贯性["评分"])
        
        return {
            "连贯性评分": 连贯性评分,
            "问题": 问题列表,
            "建议": 建议列表,
            "详细分析": {
                "人物连贯性": 人物连贯性,
                "情节连贯性": 情节连贯性,
                "时间连贯性": 时间连贯性
            }
        }
    
    def 检查人物连贯性(self, 上下文: str, 新内容: str) -> Dict[str, Any]:
        """检查人物设定的一致性"""
        # 提取上下文中的人物信息
        上下文人物 = self.提取人物信息(上下文)
        新内容人物 = self.提取人物信息(新内容)
        
        问题 = []
        匹配人物数 = 0
        
        for 人物, 特征 in 新内容人物.items():
            if 人物 in 上下文人物:
                # 检查特征一致性
                上下文特征 = 上下文人物[人物]
                不一致特征 = []
                for 特征名, 特征值 in 特征.items():
                    if 特征名 in 上下文特征 and 上下文特征[特征名] != 特征值:
                        不一致特征.append(f"{特征名}: {上下文特征[特征名]} -> {特征值}")
                
                if 不一致特征:
                    问题.append(f"人物'{人物}'特征不一致: {', '.join(不一致特征)}")
                else:
                    匹配人物数 += 1
            else:
                # 新人物，没问题
                匹配人物数 += 1
        
        总人物数 = max(len(新内容人物), 1)
        评分 = 匹配人物数 / 总人物数
        
        return {"评分": 评分, "问题": 问题, "上下文人物": 上下文人物, "新内容人物": 新内容人物}
    
    def 检查情节连贯性(self, 上下文: str, 新内容: str) -> Dict[str, Any]:
        """检查情节发展的连贯性"""
        # 提取关键事件
        上下文事件 = self.提取关键事件(上下文)
        新内容事件 = self.提取关键事件(新内容)
        
        if not 上下文事件:
            return {"评分": 1.0, "问题": []}
        
        # 检查事件逻辑关系
        问题 = []
        最后事件 = 上下文事件[-1] if 上下文事件 else ""
        
        # 简单逻辑检查（实际应该更复杂）
        if "死亡" in 最后事件 and "说话" in 新内容:
            问题.append("角色死亡后不能说话")
        
        if "离开" in 最后事件 and "在场" in 新内容:
            问题.append("角色离开后不应在场")
        
        评分 = 1.0 - len(问题) * 0.3
        
        return {"评分": 评分, "问题": 问题, "上下文事件": 上下文事件, "新内容事件": 新内容事件}
    
    def 检查时间连贯性(self, 上下文: str, 新内容: str) -> Dict[str, Any]:
        """检查时间线的一致性"""
        # 提取时间信息
        上下文时间 = self.提取时间信息(上下文)
        新内容时间 = self.提取时间信息(新内容)
        
        if not 上下文时间 or not 新内容时间:
            return {"评分": 1.0, "问题": []}
        
        问题 = []
        最后时间 = 上下文时间[-1] if 上下文时间 else ""
        当前时间 = 新内容时间[0] if 新内容时间 else ""
        
        # 简单时间检查
        if 最后时间 and 当前时间:
            if "早上" in 最后时间 and "晚上" in 当前时间:
                # 合理的时间推进
                pass
            elif "晚上" in 最后时间 and "早上" in 当前时间:
                # 合理的时间推进
                pass
            elif 最后时间 == 当前时间:
                # 同一时间，没问题
                pass
            else:
                # 时间跳跃可能不合理
                问题.append(f"时间线跳跃: {最后时间} -> {当前时间}")
        
        评分 = 1.0 - len(问题) * 0.5
        
        return {"评分": 评分, "问题": 问题, "上下文时间": 上下文时间, "新内容时间": 新内容时间}
    
    def 提取人物信息(self, 文本: str) -> Dict[str, Dict[str, str]]:
        """从文本中提取人物信息"""
        人物信息 = {}
        
        # 简单的人物提取（实际应该更复杂）
        人物模式 = r'([\u4e00-\u9fa5]{2,4})[说道想叫]'
        人物匹配 = re.findall(人物模式, 文本)
        
        for 人物 in set(人物匹配):
            人物信息[人物] = {
                "名称": 人物,
                "出现次数": 文本.count(人物)
            }
        
        return 人物信息
    
    def 提取关键事件(self, 文本: str) -> List[str]:
        """从文本中提取关键事件"""
        事件列表 = []
        
        # 简单的事件提取
        事件动词 = ["说", "做", "去", "来", "打", "杀", "爱", "恨", "生", "死"]
        句子列表 = re.split(r'[。！？!?]', 文本)
        
        for 句子 in 句子列表:
            if any(动词 in 句子 for 动词 in 事件动词):
                事件列表.append(句子.strip())
        
        return 事件列表
    
    def 提取时间信息(self, 文本: str) -> List[str]:
        """从文本中提取时间信息"""
        时间列表 = []
        
        时间关键词 = ["早上", "中午", "下午", "晚上", "清晨", "黄昏", "午夜", "今天", "明天", "昨天"]
        
        for 关键词 in 时间关键词:
            if 关键词 in 文本:
                时间列表.append(关键词)
        
        return 时间列表

class 逻辑冲突检测器:
    """逻辑冲突检测器"""
    def __init__(self):
        self.配置管理器 = 获取配置管理器()
        self.日志器 = logging.getLogger('逻辑冲突检测器')
        self.冲突规则库 = self.初始化冲突规则库()
    
    def 初始化冲突规则库(self) -> Dict[str, Callable]:
        """初始化冲突检测规则库"""
        return {
            "人物死亡后活动": self.检测人物死亡后活动,
            "时间线矛盾": self.检测时间线矛盾,
            "空间位置矛盾": self.检测空间位置矛盾,
            "能力设定矛盾": self.检测能力设定矛盾,
            "情节逻辑矛盾": self.检测情节逻辑矛盾
        }
    
    def 检测冲突(self, 内容: str, 上下文: str = "") -> Dict[str, Any]:
        """检测内容中的逻辑冲突"""
        冲突列表 = []
        冲突详情 = {}
        
        for 规则名, 检测函数 in self.冲突规则库.items():
            try:
                结果 = 检测函数(内容, 上下文)
                if 结果["发现冲突"]:
                    冲突列表.append(规则名)
                    冲突详情[规则名] = 结果
            except Exception as e:
                self.日志器.error(f"冲突检测规则执行失败 {规则名}: {e}")
        
        冲突严重度 = self.计算冲突严重度(冲突列表, 冲突详情)
        冲突评分 = 1.0 - 冲突严重度
        
        return {
            "发现冲突": len(冲突列表) > 0,
            "冲突列表": 冲突列表,
            "冲突详情": 冲突详情,
            "冲突严重度": 冲突严重度,
            "冲突评分": 冲突评分,
            "建议修复": self.生成修复建议(冲突列表, 冲突详情)
        }
    
    def 检测人物死亡后活动(self, 内容: str, 上下文: str) -> Dict[str, Any]:
        """检测人物死亡后的活动"""
        冲突细节 = []
        
        # 提取死亡信息
        死亡模式 = r'([\u4e00-\u9fa5]{2,4})[死逝终]'
        死亡人物 = set(re.findall(死亡模式, 上下文 + 内容))
        
        for 人物 in 死亡人物:
            # 检查死亡后是否还有活动
            活动模式 = f'{人物}[说做走去来]'
            if re.search(活动模式, 内容):
                冲突细节.append(f"人物'{人物}'死亡后仍有活动")
        
        return {
            "发现冲突": len(冲突细节) > 0,
            "冲突细节": 冲突细节,
            "严重度": 0.8
        }
    
    def 检测时间线矛盾(self, 内容: str, 上下文: str) -> Dict[str, Any]:
        """检测时间线矛盾"""
        冲突细节 = []
        
        # 提取时间信息
        时间关键词 = ["早上", "中午", "下午", "晚上", "清晨", "黄昏", "午夜"]
        内容时间 = [词 for 词 in 时间关键词 if 词 in 内容]
        上下文时间 = [词 for 词 in 时间关键词 if 词 in 上下文]
        
        if 内容时间 and 上下文时间:
            # 简单的时间顺序检查
            时间顺序 = ["清晨", "早上", "中午", "下午", "黄昏", "晚上", "午夜"]
            最后时间索引 = max([时间顺序.index(时间) for 时间 in 上下文时间 if 时间 in 时间顺序] or [0])
            当前时间索引 = min([时间顺序.index(时间) for 时间 in 内容时间 if 时间 in 时间顺序] or [len(时间顺序)-1])
            
            if 当前时间索引 < 最后时间索引:
                冲突细节.append(f"时间线倒退: {上下文时间} -> {内容时间}")
        
        return {
            "发现冲突": len(冲突细节) > 0,
            "冲突细节": 冲突细节,
            "严重度": 0.6
        }
    
    def 检测空间位置矛盾(self, 内容: str, 上下文: str) -> Dict[str, Any]:
        """检测空间位置矛盾"""
        冲突细节 = []
        
        # 简单的位置检查
        位置动词 = ["到达", "来到", "进入", "离开"]
        位置名词 = ["房间", "城市", "国家", "世界"]
        
        内容位置 = [词 for 词 in 位置名词 if 词 in 内容]
        上下文位置 = [词 for 词 in 位置名词 if 词 in 上下文]
        
        if 内容位置 and 上下文位置:
            # 检查位置变化是否合理
            位置变化动词 = [词 for 词 in 位置动词 if 词 in 内容]
            if not 位置变化动词 and 内容位置 != 上下文位置:
                冲突细节.append(f"位置跳跃: {上下文位置} -> {内容位置} 没有移动过程")
        
        return {
            "发现冲突": len(冲突细节) > 0,
            "冲突细节": 冲突细节,
            "严重度": 0.5
        }
    
    def 检测能力设定矛盾(self, 内容: str, 上下文: str) -> Dict[str, Any]:
        """检测能力设定矛盾"""
        冲突细节 = []
        
        # 简单的能力检查
        能力关键词 = ["不会", "不能", "无法", "没有能力"]
        获得能力词 = ["学会", "获得", "掌握", "领悟"]
        
        for 能力词 in 能力关键词:
            if 能力词 in 上下文 and 获得能力词 in 内容:
                冲突细节.append("角色突然获得之前没有的能力")
                break
        
        return {
            "发现冲突": len(冲突细节) > 0,
            "冲突细节": 冲突细节,
            "严重度": 0.7
        }
    
    def 检测情节逻辑矛盾(self, 内容: str, 上下文: str) -> Dict[str, Any]:
        """检测情节逻辑矛盾"""
        冲突细节 = []
        
        # 简单的情节逻辑检查
        矛盾模式 = [
            (r'非常富有', r'没有钱'),
            (r'身体健康', r'患有重病'),
            (r'深爱着', r'讨厌'),
            (r'信任', r'背叛')
        ]
        
        for 模式1, 模式2 in 矛盾模式:
            if (re.search(模式1, 上下文) and re.search(模式2, 内容)) or \
               (re.search(模式1, 内容) and re.search(模式2, 上下文)):
                冲突细节.append(f"情节逻辑矛盾: {模式1} 与 {模式2}")
        
        return {
            "发现冲突": len(冲突细节) > 0,
            "冲突细节": 冲突细节,
            "严重度": 0.9
        }
    
    def 计算冲突严重度(self, 冲突列表: List[str], 冲突详情: Dict[str, Any]) -> float:
        """计算整体冲突严重度"""
        if not 冲突列表:
            return 0.0
        
        总严重度 = 0.0
        for 冲突 in 冲突列表:
            总严重度 += 冲突详情[冲突].get("严重度", 0.5)
        
        return min(总严重度 / len(冲突列表), 1.0)
    
    def 生成修复建议(self, 冲突列表: List[str], 冲突详情: Dict[str, Any]) -> List[str]:
        """生成修复建议"""
        建议列表 = []
        
        for 冲突 in 冲突列表:
            详情 = 冲突详情[冲突]
            for 细节 in 详情.get("冲突细节", []):
                if "死亡" in 细节:
                    建议列表.append("调整人物状态或删除死亡后的活动")
                elif "时间" in 细节:
                    建议列表.append("调整时间顺序或添加时间过渡")
                elif "位置" in 细节:
                    建议列表.append("添加位置移动描述")
                elif "能力" in 细节:
                    建议列表.append("调整能力设定或添加能力获得过程")
                elif "情节" in 细节:
                    建议列表.append("修改矛盾的情节设定")
        
        return list(set(建议列表))  # 去重

class 质量评估器:
    """质量评估器"""
    def __init__(self):
        self.配置管理器 = 获取配置管理器()
        self.日志器 = logging.getLogger('质量评估器')
        self.质量标准 = self.初始化质量标准()
    
    def 初始化质量标准(self) -> Dict[str, Callable]:
        """初始化质量评估标准"""
        return {
            "文笔流畅度": self.评估文笔流畅度,
            "情节吸引力": self.评估情节吸引力,
            "人物塑造": self.评估人物塑造,
            "逻辑合理性": self.评估逻辑合理性,
            "情感感染力": self.评估情感感染力,
            "创新性": self.评估创新性
        }
    
    def 评估质量(self, 内容: str, 风格参数: 风格参数 = None) -> Dict[str, Any]:
        """全面评估内容质量"""
        评分详情 = {}
        总评分 = 0.0
        
        for 标准名, 评估函数 in self.质量标准.items():
            try:
                评分结果 = 评估函数(内容, 风格参数)
                评分详情[标准名] = 评分结果
                总评分 += 评分结果["评分"]
            except Exception as e:
                self.日志器.error(f"质量评估标准执行失败 {标准名}: {e}")
                评分详情[标准名] = {"评分": 0.5, "说明": "评估失败"}
        
        平均评分 = 总评分 / len(self.质量标准) if self.质量标准 else 0.5
        质量等级 = self.评分转等级(平均评分)
        
        return {
            "总体评分": 平均评分,
            "质量等级": 质量等级,
            "评分详情": 评分详情,
            "改进建议": self.生成改进建议(评分详情)
        }
    
    def 评估文笔流畅度(self, 内容: str, 风格参数: 风格参数 = None) -> Dict[str, Any]:
        """评估文笔流畅度"""
        if len(内容) < 50:
            return {"评分": 0.5, "说明": "内容过短，无法准确评估"}
        
        # 计算句子平均长度
        句子列表 = re.split(r'[。！？!?]', 内容)
        句子列表 = [句子.strip() for 句子 in 句子列表 if 句子.strip()]
        
        if not 句子列表:
            return {"评分": 0.3, "说明": "没有完整的句子"}
        
        平均句长 = sum(len(句子) for 句子 in 句子列表) / len(句子列表)
        
        # 检查句式多样性
        句式变化 = self.计算句式变化(句子列表)
        
        # 检查词汇丰富度
        词汇丰富度 = self.计算词汇丰富度(内容)
        
        # 综合评分
        句长评分 = min(平均句长 / 25, 1.0)  # 25字为理想句长
        流畅度评分 = (句长评分 + 句式变化 + 词汇丰富度) / 3
        
        说明 = f"平均句长:{平均句长:.1f}字, 句式变化:{句式变化:.2f}, 词汇丰富度:{词汇丰富度:.2f}"
        
        return {"评分": 流畅度评分, "说明": 说明}
    
    def 评估情节吸引力(self, 内容: str, 风格参数: 风格参数 = None) -> Dict[str, Any]:
        """评估情节吸引力"""
        # 检查悬念设置
        悬念词 = ["突然", "意外", "没想到", "竟然", "居然", "秘密", "谜"]
        悬念密度 = sum(内容.count(词) for 词 in 悬念词) / max(len(内容) / 100, 1)
        
        # 检查冲突设置
        冲突词 = ["矛盾", "冲突", "对抗", "战斗", "争论", "分歧"]
        冲突密度 = sum(内容.count(词) for 词 in 冲突词) / max(len(内容) / 100, 1)
        
        # 检查情感波动
        情感词 = ["高兴", "悲伤", "愤怒", "恐惧", "惊讶", "爱", "恨"]
        情感密度 = sum(内容.count(词) for 词 in 情感词) / max(len(内容) / 100, 1)
        
        吸引力评分 = min((悬念密度 * 0.4 + 冲突密度 * 0.4 + 情感密度 * 0.2) * 5, 1.0)
        
        说明 = f"悬念密度:{悬念密度:.2f}, 冲突密度:{冲突密度:.2f}, 情感密度:{情感密度:.2f}"
        
        return {"评分": 吸引力评分, "说明": 说明}
    
    def 评估人物塑造(self, 内容: str, 风格参数: 风格参数 = None) -> Dict[str, Any]:
        """评估人物塑造"""
        # 提取人物信息
        人物信息 = self.提取人物信息(内容)
        
        if not 人物信息:
            return {"评分": 0.3, "说明": "没有发现人物描写"}
        
        # 计算人物塑造深度
        塑造评分 = 0.0
        for 人物, 信息 in 人物信息.items():
            # 检查对话
            对话次数 = 信息.get("对话次数", 0)
            # 检查动作
            动作次数 = 信息.get("动作次数", 0)
            # 检查心理
            心理次数 = 信息.get("心理次数", 0)
            
            人物评分 = min((对话次数 * 0.4 + 动作次数 * 0.4 + 心理次数 * 0.2) / 5, 1.0)
            塑造评分 += 人物评分
        
        平均塑造评分 = 塑造评分 / len(人物信息) if 人物信息 else 0
        
        说明 = f"发现{len(人物信息)}个人物，平均塑造评分:{平均塑造评分:.2f}"
        
        return {"评分": 平均塑造评分, "说明": 说明}
    
    def 评估逻辑合理性(self, 内容: str, 风格参数: 风格参数 = None) -> Dict[str, Any]:
        """评估逻辑合理性"""
        # 使用冲突检测器
        冲突检测器 = 逻辑冲突检测器()
        冲突结果 = 冲突检测器.检测冲突(内容)
        
        逻辑评分 = 冲突结果["冲突评分"]
        
        说明 = f"逻辑合理性评分:{逻辑评分:.2f}, 发现{len(冲突结果['冲突列表'])}个冲突"
        
        return {"评分": 逻辑评分, "说明": 说明}
    
    def 评估情感感染力(self, 内容: str, 风格参数: 风格参数 = None) -> Dict[str, Any]:
        """评估情感感染力"""
        情感词汇库 = {
            "喜悦": ["高兴", "快乐", "欣喜", "幸福", "笑容", "开心"],
            "悲伤": ["伤心", "难过", "痛苦", "悲哀", "泪水", "哭泣"],
            "愤怒": ["生气", "愤怒", "怒火", "愤慨", "暴怒"],
            "恐惧": ["害怕", "恐惧", "惊慌", "恐怖", "胆战"],
            "爱慕": ["爱", "喜欢", "倾心", "爱慕", "钟情"]
        }
        
        情感强度 = {}
        for 情感类型, 词汇列表 in 情感词汇库.items():
            出现次数 = sum(内容.count(词汇) for 词汇 in 词汇列表)
            情感强度[情感类型] = 出现次数 / max(len(内容) / 100, 1)
        
        # 计算情感多样性
        有效情感数 = sum(1 for 强度 in 情感强度.values() if 强度 > 0.1)
        情感多样性 = min(有效情感数 / 3, 1.0)  # 最多3种主要情感
        
        # 计算情感强度
        最大情感强度 = max(情感强度.values()) if 情感强度 else 0
        情感强度评分 = min(最大情感强度 * 2, 1.0)
        
        感染力评分 = (情感多样性 * 0.3 + 情感强度评分 * 0.7)
        
        说明 = f"情感多样性:{情感多样性:.2f}, 情感强度:{情感强度评分:.2f}"
        
        return {"评分": 感染力评分, "说明": 说明}
    
    def 评估创新性(self, 内容: str, 风格参数: 风格参数 = None) -> Dict[str, Any]:
        """评估创新性"""
        # 检查新颖词汇
        常见词汇 = ["说道", "想到", "看到", "走到", "开始", "然后", "接着"]
        常见词比例 = sum(内容.count(词) for 词 in 常见词汇) / max(len(内容) / 10, 1)
        
        # 检查句式创新
        句子列表 = re.split(r'[。！？!?]', 内容)
        句式重复度 = self.计算句式重复度(句子列表)
        
        创新性评分 = max(0, 1.0 - 常见词比例 * 0.5 - 句式重复度 * 0.5)
        
        说明 = f"常见词比例:{常见词比例:.2f}, 句式重复度:{句式重复度:.2f}"
        
        return {"评分": 创新性评分, "说明": 说明}
    
    def 计算句式变化(self, 句子列表: List[str]) -> float:
        """计算句式变化程度"""
        if len(句子列表) < 2:
            return 0.5
        
        # 计算句子长度变化
        句长列表 = [len(句子) for 句子 in 句子列表]
        句长标准差 = np.std(句长列表) if hasattr(np, 'std') else 10  # 简化处理
        句长变化 = min(句长标准差 / 15, 1.0)  # 15字为标准差基准
        
        # 计算开头词变化
        开头词列表 = [句子[:2] for 句子 in 句子列表 if len(句子) >= 2]
        开头词变化 = len(set(开头词列表)) / len(开头词列表) if 开头词列表 else 0.5
        
        return (句长变化 + 开头词变化) / 2
    
    def 计算词汇丰富度(self, 内容: str) -> float:
        """计算词汇丰富度"""
        中文词 = re.findall(r'[\u4e00-\u9fa5]{2,}', 内容)
        if not 中文词:
            return 0.3
        
        唯一词数 = len(set(中文词))
        总词数 = len(中文词)
        
        丰富度 = 唯一词数 / 总词数 if 总词数 > 0 else 0
        return min(丰富度 * 2, 1.0)  # 标准化到0-1
    
    def 提取人物信息(self, 内容: str) -> Dict[str, Dict[str, int]]:
        """提取人物信息"""
        人物信息 = {}
        
        # 简单的人物提取
        人物模式 = r'([\u4e00-\u9fa5]{2,4})[说道想叫]'
        人物列表 = re.findall(人物模式, 内容)
        
        for 人物 in set(人物列表):
            对话次数 = 内容.count(人物 + "说") + 内容.count(人物 + "道")
            动作次数 = 内容.count(人物 + "走") + 内容.count(人物 + "跑") + 内容.count(人物 + "打")
            心理次数 = 内容.count(人物 + "想") + 内容.count(人物 + "觉得")
            
            人物信息[人物] = {
                "对话次数": 对话次数,
                "动作次数": 动作次数,
                "心理次数": 心理次数
            }
        
        return 人物信息
    
    def 计算句式重复度(self, 句子列表: List[str]) -> float:
        """计算句式重复度"""
        if len(句子列表) < 2:
            return 0.5
        
        重复计数 = 0
        for i in range(len(句子列表) - 1):
            if 句子列表[i][:5] == 句子列表[i+1][:5]:  # 前5个字相同
                重复计数 += 1
        
        重复度 = 重复计数 / (len(句子列表) - 1)
        return 重复度
    
    def 评分转等级(self, 评分: float) -> 质量等级:
        """将评分转换为质量等级"""
        if 评分 >= 0.8:
            return 质量等级.优秀
        elif 评分 >= 0.6:
            return 质量等级.良好
        elif 评分 >= 0.4:
            return 质量等级.一般
        else:
            return 质量等级.较差
    
    def 生成改进建议(self, 评分详情: Dict[str, Any]) -> List[str]:
        """根据评分生成改进建议"""
        建议列表 = []
        
        for 标准名, 详情 in 评分详情.items():
            评分 = 详情["评分"]
            if 评分 < 0.6:
                if 标准名 == "文笔流畅度":
                    建议列表.append("增加句式变化，避免重复句式")
                elif 标准名 == "情节吸引力":
                    建议列表.append("增加悬念和冲突设置")
                elif 标准名 == "人物塑造":
                    建议列表.append("加强人物对话和心理描写")
                elif 标准名 == "逻辑合理性":
                    建议列表.append("检查情节逻辑，避免矛盾")
                elif 标准名 == "情感感染力":
                    建议列表.append("加强情感描写，让读者共鸣")
                elif 标准名 == "创新性":
                    建议列表.append("尝试使用新颖的表达方式")
        
        return 建议列表

class 个性化学习器:
    """个性化学习器 - 基于用户反馈优化生成"""
    def __init__(self):
        self.配置管理器 = 获取配置管理器()
        self.风格管理系统 = 获取风格管理系统()
        self.日志器 = logging.getLogger('个性化学习器')
        self.用户偏好库 = {}
        self.反馈记录 = []
        
    def 记录用户反馈(self, 用户ID: str, 生成结果: 生成结果, 用户评分: float, 反馈意见: str = ""):
        """记录用户反馈"""
        反馈记录 = {
            "用户ID": 用户ID,
            "时间戳": time.time(),
            "生成参数": 生成结果.标签,
            "用户评分": 用户评分,
            "系统评分": 生成结果.质量评分,
            "反馈意见": 反馈意见,
            "内容哈希": hashlib.md5(生成结果.内容.encode()).hexdigest()
        }
        
        self.反馈记录.append(反馈记录)
        
        # 更新用户偏好
        self.更新用户偏好(用户ID, 生成结果, 用户评分)
        
        # 如果评分高，训练相关风格
        if 用户评分 >= 4.0:
            self.训练相关风格(生成结果, 用户评分)
    
    def 更新用户偏好(self, 用户ID: str, 生成结果: 生成结果, 用户评分: float):
        """更新用户偏好"""
        if 用户ID not in self.用户偏好库:
            self.用户偏好库[用户ID] = {
                "偏好风格": {},
                "偏好主题": {},
                "偏好标签": {},
                "总体评分": 0.0,
                "反馈次数": 0
            }
        
        用户偏好 = self.用户偏好库[用户ID]
        
        # 更新风格偏好
        风格权重 = 用户评分 / 5.0
        for 标签 in 生成结果.标签:
            if "风格" in 标签:
                当前权重 = 用户偏好["偏好风格"].get(标签, 0.0)
                用户偏好["偏好风格"][标签] = (当前权重 * 用户偏好["反馈次数"] + 风格权重) / (用户偏好["反馈次数"] + 1)
        
        # 更新主题偏好
        for 标签 in 生成结果.标签:
            if any(关键词 in 标签 for 关键词 in ["主题", "题材", "类型"]):
                当前权重 = 用户偏好["偏好主题"].get(标签, 0.0)
                用户偏好["偏好主题"][标签] = (当前权重 * 用户偏好["反馈次数"] + 风格权重) / (用户偏好["反馈次数"] + 1)
        
        # 更新总体统计
        用户偏好["总体评分"] = (用户偏好["总体评分"] * 用户偏好["反馈次数"] + 用户评分) / (用户偏好["反馈次数"] + 1)
        用户偏好["反馈次数"] += 1
    
    def 训练相关风格(self, 生成结果: 生成结果, 用户评分: float):
        """训练相关风格"""
        # 提取风格标签
        风格标签 = [标签 for 标签 in 生成结果.标签 if "风格" in 标签]
        
        for 风格名 in 风格标签:
            # 训练风格
            self.风格管理系统.训练风格(风格名, 生成结果.内容, 用户评分)
    
    def 获取用户偏好(self, 用户ID: str) -> Dict[str, Any]:
        """获取用户偏好"""
        return self.用户偏好库.get(用户ID, {
            "偏好风格": {},
            "偏好主题": {},
            "偏好标签": {},
            "总体评分": 0.0,
            "反馈次数": 0
        })
    
    def 生成个性化建议(self, 用户ID: str, 当前参数: 生成参数) -> Dict[str, Any]:
        """生成个性化建议"""
        用户偏好 = self.获取用户偏好(用户ID)
        
        if 用户偏好["反馈次数"] == 0:
            return {"建议": "暂无个性化建议，请先提供一些反馈"}
        
        建议 = {
            "推荐风格": [],
            "推荐主题": [],
            "参数调整建议": []
        }
        
        # 推荐偏好风格
        偏好风格 = sorted(用户偏好["偏好风格"].items(), key=lambda x: x[1], reverse=True)[:3]
        for 风格名, 权重 in 偏好风格:
            if 权重 > 0.7:
                建议["推荐风格"].append(风格名)
        
        # 推荐偏好主题
        偏好主题 = sorted(用户偏好["偏好主题"].items(), key=lambda x: x[1], reverse=True)[:3]
        for 主题名, 权重 in 偏好主题:
            if 权重 > 0.7:
                建议["推荐主题"].append(主题名)
        
        # 参数调整建议
        if 用户偏好["总体评分"] < 3.0:
            建议["参数调整建议"].append("建议降低生成复杂度，提高可读性")
        elif 用户偏好["总体评分"] > 4.0:
            建议["参数调整建议"].append("可以尝试更复杂的叙事结构")
        
        return 建议

class 智能生成核心:
    """智能生成核心 - 主生成引擎"""
    def __init__(self):
        self.配置管理器 = 获取配置管理器()
        self.风格管理系统 = 获取风格管理系统()
        self.上下文管理器 = 上下文管理器()
        self.冲突检测器 = 逻辑冲突检测器()
        self.质量评估器 = 质量评估器()
        self.个性化学习器 = 个性化学习器()
        self.日志器 = logging.getLogger('智能生成核心')
        
        # 生成状态
        self.生成任务队列 = PriorityQueue()
        self.正在生成的任务 = {}
        self.生成结果缓存 = {}
        
        # 启动生成线程
        self.生成线程 = threading.Thread(target=self.生成工作线程, daemon=True)
        self.生成线程.start()
    
    def 生成工作线程(self):
        """生成工作线程"""
        while True:
            try:
                # 获取任务
                优先级, 任务 = self.生成任务队列.get()
                
                任务ID = 任务["任务ID"]
                self.正在生成的任务[任务ID] = 生成状态.生成中
                
                # 执行生成
                结果 = self.执行生成任务(任务)
                
                # 保存结果
                self.生成结果缓存[任务ID] = 结果
                self.正在生成的任务[任务ID] = 生成状态.完成
                
                self.生成任务队列.task_done()
                
            except Exception as e:
                self.日志器.error(f"生成工作线程错误: {e}")
                if 任务ID in self.正在生成的任务:
                    self.正在生成的任务[任务ID] = 生成状态.失败
    
    def 执行生成任务(self, 任务: Dict[str, Any]) -> 生成结果:
        """执行生成任务"""
        任务ID = 任务["任务ID"]
        参数 = 任务["参数"]
        会话ID = 任务.get("会话ID", 任务ID)
        
        self.日志器.info(f"开始生成任务: {任务ID}")
        开始时间 = time.time()
        
        try:
            # 获取风格参数
            风格参数 = self.风格管理系统.获取风格(参数.风格)
            
            # 获取上下文
            上下文 = self.上下文管理器.获取上下文(会话ID)
            
            # 生成内容
            生成内容 = self.生成内容(参数, 风格参数, 上下文)
            
            # 分析连贯性
            连贯性分析 = self.上下文管理器.分析上下文连贯性(会话ID, 生成内容)
            
            # 检测冲突
            冲突检测 = self.冲突检测器.检测冲突(生成内容, 上下文)
            
            # 评估质量
            质量评估 = self.质量评估器.评估质量(生成内容, 风格参数)
            
            # 创建结果
            结果 = 生成结果(
                状态=生成状态.完成,
                内容=生成内容,
                质量评分=质量评估["总体评分"],
                质量等级=质量评估["质量等级"],
                实际字数=len(生成内容),
                生成时间=time.time() - 开始时间,
                版本号=1,
                标签=参数.标签列表,
                冲突检测=冲突检测,
                审核结果=None,
                用户反馈=None
            )
            
            # 添加上下文
            self.上下文管理器.添加上下文(会话ID, 生成内容, {
                "任务ID": 任务ID,
                "质量评分": 结果.质量评分,
                "冲突检测": 冲突检测
            })
            
            self.日志器.info(f"生成任务完成: {任务ID}, 质量评分: {结果.质量评分:.2f}")
            
            return 结果
            
        except Exception as e:
            self.日志器.error(f"生成任务失败 {任务ID}: {e}")
            return 生成结果(
                状态=生成状态.失败,
                内容=f"生成失败: {e}",
                质量评分=0.0,
                质量等级=质量等级.较差,
                实际字数=0,
                生成时间=time.time() - 开始时间,
                版本号=1,
                标签=[],
                冲突检测={"发现冲突": False, "冲突列表": []}
            )
    
    def 生成内容(self, 参数: 生成参数, 风格参数: 风格参数, 上下文: str) -> str:
        """生成内容（核心生成逻辑）"""
        # 这里应该是真正的AI模型调用
        # 由于环境限制，我们使用模板生成
        
        主题 = 参数.主题
        风格名 = 参数.风格
        目标字数 = 参数.目标字数
        
        # 基础模板
        模板库 = {
            "热血战斗风": [
                f"{主题}面对强敌，毫不退缩。",
                "热血在体内沸腾，力量源源不断涌出。",
                "这一战，必须胜利！为了信念，为了荣耀！",
                "敌人虽然强大，但意志更加坚定。",
                "最终，正义必将战胜邪恶！"
            ],
            "虐心言情风": [
                f"看着{主题}远去的背影，心中涌起无尽的悲伤。",
                "泪水模糊了视线，却模糊不了心中的痛。",
                "如果时光可以倒流，我定会紧紧抓住你的手。",
                "爱情就像指间沙，越想抓紧，流失得越快。",
                "有些错过，就是一辈子。"
            ],
            "悬疑推理风": [
                f"关于{主题}的真相，似乎隐藏着更深的秘密。",
                "每个线索都指向不同的方向，真相究竟在哪里？",
                "当最后的谜底揭开时，所有人都震惊了。",
                "看似无关的细节，往往是破案的关键。",
                "真相往往比想象更加残酷。"
            ]
        }
        
        # 选择模板
        模板列表 = 模板库.get(风格名, 模板库["热血战斗风"])
        
        # 生成内容
        生成内容 = ""
        while len(生成内容) < 目标字数 and 模板列表:
            句子 = random.choice(模板列表)
            生成内容 += 句子 + " "
            
            # 添加一些变化
            if random.random() < 0.3:
                生成内容 += random.choice(["然而", "但是", "不过", "与此同时"]) + " "
        
        # 添加上下文衔接
        if 上下文:
            衔接词 = ["接着", "随后", "就在这时", "与此同时"]
            生成内容 = random.choice(衔接词) + "，" + 生成内容
        
        return 生成内容.strip()
    
    def 提交生成任务(self, 参数: 生成参数, 会话ID: str = None, 优先级: int = 5) -> str:
        """提交生成任务"""
        任务ID = hashlib.md5(f"{参数}{time.time()}".encode()).hexdigest()[:8]
        
        任务 = {
            "任务ID": 任务ID,
            "参数": 参数,
            "会话ID": 会话ID or 任务ID,
            "提交时间": time.time(),
            "优先级": 优先级
        }
        
        self.生成任务队列.put((优先级, 任务))
        self.正在生成的任务[任务ID] = 生成状态.等待中
        
        self.日志器.info(f"提交生成任务: {任务ID}, 优先级: {优先级}")
        return 任务ID
    
    def 获取任务状态(self, 任务ID: str) -> 生成状态:
        """获取任务状态"""
        return self.正在生成的任务.get(任务ID, 生成状态.失败)
    
    def 获取生成结果(self, 任务ID: str) -> Optional[生成结果]:
        """获取生成结果"""
        return self.生成结果缓存.get(任务ID)
    
    def 多版本生成(self, 参数: 生成参数, 版本数: int = 3) -> List[生成结果]:
        """多版本并行生成"""
        任务ID列表 = []
        
        # 提交多个版本任务
        for i in range(版本数):
            版本参数 = copy.deepcopy(参数)
            版本参数.标签列表.append(f"版本_{i+1}")
            
            任务ID = self.提交生成任务(版本参数, 优先级=10-i)  # 版本1优先级最高
            任务ID列表.append(任务ID)
        
        # 等待所有任务完成
        结果列表 = []
        for 任务ID in 任务ID列表:
            while self.获取任务状态(任务ID) not in [生成状态.完成, 生成状态.失败]:
                time.sleep(0.1)
            
            结果 = self.获取生成结果(任务ID)
            if 结果 and 结果.状态 == 生成状态.完成:
                结果列表.append(结果)
        
        # 按质量评分排序
        结果列表.sort(key=lambda x: x.质量评分, reverse=True)
        return 结果列表
    
    def 实时调整参数(self, 任务ID: str, 新参数: 生成参数) -> bool:
        """实时调整生成参数"""
        # 在实际系统中，这里应该能够调整正在生成的任务
        # 目前我们只能取消旧任务并创建新任务
        if 任务ID in self.正在生成的任务 and self.正在生成的任务[任务ID] == 生成状态.生成中:
            self.日志器.warning(f"无法调整正在生成的任务: {任务ID}")
            return False
        
        # 创建新任务
        新任务ID = self.提交生成任务(新参数, 优先级=1)
        return 新任务ID is not None
    
    def 标签化生成(self, 标签列表: List[str], 目标字数: int = 1000) -> 生成结果:
        """基于标签的生成"""
        # 从标签中提取主题和风格
        主题标签 = [标签 for 标签 in 标签列表 if any(词 in 标签 for 词 in ["主题", "题材", "关于"])]
        风格标签 = [标签 for 标签 in 标签列表 if "风格" in 标签]
        
        主题 = 主题标签[0] if 主题标签 else "未知主题"
        风格 = 风格标签[0] if 风格标签 else "热血战斗风"
        
        参数 = 生成参数(
            主题=主题,
            风格=风格,
            目标字数=目标字数,
            标签列表=标签列表
        )
        
        任务ID = self.提交生成任务(参数, 优先级=5)
        
        # 等待完成
        while self.获取任务状态(任务ID) not in [生成状态.完成, 生成状态.失败]:
            time.sleep(0.1)
        
        return self.获取生成结果(任务ID)
    
    def 获取系统状态(self) -> Dict[str, Any]:
        """获取系统状态"""
        return {
            "等待任务数": self.生成任务队列.qsize(),
            "正在生成任务数": len([状态 for 状态 in self.正在生成的任务.values() if 状态 == 生成状态.生成中]),
            "已完成任务数": len(self.生成结果缓存),
            "缓存任务数": len(self.正在生成的任务),
            "上下文缓存大小": self.上下文管理器.当前缓存大小,
            "用户反馈数": len(self.个性化学习器.反馈记录)
        }

# 智能生成核心单例
智能生成核心实例 = None

def 获取智能生成核心():
    """获取智能生成核心单例"""
    global 智能生成核心实例
    if 智能生成核心实例 is None:
        智能生成核心实例 = 智能生成核心()
    return 智能生成核心实例

if __name__ == "__main__":
    # 测试智能生成核心
    生成核心 = 获取智能生成核心()
    
    # 测试生成任务
    参数 = 生成参数(
        主题="英雄的战斗",
        风格="热血战斗风", 
        目标字数=200,
        标签列表=["战斗", "英雄", "热血"]
    )
    
    任务ID = 生成核心.提交生成任务(参数)
    print(f"提交生成任务: {任务ID}")
    
    # 等待完成
    while 生成核心.获取任务状态(任务ID) not in [生成状态.完成, 生成状态.失败]:
        time.sleep(0.1)
    
    结果 = 生成核心.获取生成结果(任务ID)
    if 结果:
        print(f"生成结果: {结果.内容}")
        print(f"质量评分: {结果.质量评分:.2f}")
        print(f"冲突检测: {结果.冲突检测}")
    
    # 测试系统状态
    状态 = 生成核心.获取系统状态()
    print(f"系统状态: {状态}")